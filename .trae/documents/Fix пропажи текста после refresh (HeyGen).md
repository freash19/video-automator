## Что происходит (гипотезы)
1. **Изменения реально не сохраняются перед `page.reload()`**: текущий `click_save_and_wait()` сначала жмёт `Meta+S`, что в браузере часто открывает системный “Save page…” диалог (не сохранение в HeyGen). В этом случае «Saved/Сохранено» может не появляться (или ловится старое уведомление), а `refresh_and_validate()` всё равно делает reload → текст после обновления «пропадает».
2. **Мы не фиксируем (commit) правку в модель редактора**: вставка через `insert_text` + быстрый `Tab`/переключение может оставлять правку «визуально» до ближайшего ререндера, но без корректного события/blur/debounce-save. После reload данные не подтягиваются, потому что не были записаны.
3. **Нет пост-проверки после вставки**: в текущем `fill_scene()` флаг `verify_scene_after_insert` по умолчанию `False`, а блок в коде пустой. В старом скрипте был read-back и 2 ретрая, поэтому «случаи неприклеившегося текста» лечились сразу.
4. **`Tab` как триггер проблем**: `Tab` после вставки может переводить фокус/менять активную сцену/триггерить перестройку DOM. В модульной версии `core/scenes.py` `Tab` убран из основного ввода (оставлен только как мягкий fallback при верификации).
5. **Ожидание “Saved/Сохранено” ненадёжно**: текущий поиск через `page.locator('div').filter(regex)` и выбор `nth(2)` может промахиваться, либо ловить не то уведомление. Тогда `saved=False` → лишь `sleep(7)` → reload слишком рано.

## Что отличает старый скрипт (что «было, а стало нет»)
- **Верификация после ввода + ретраи**: старый `fill_scene()` читает `inner_text` и при несовпадении делает до 2 повторных вставок. Это резко снижает шанс “вставили, но не зафиксировалось”.
- **Сохранение сначала через UI-кнопку**: старый `click_save_and_wait()` в первую очередь кликает кнопку с `iconpark-icon[name="saved"]`, и только если её нет — делает `Meta+S`. В новой версии порядок обратный.
- **В текущей версии `verify_scene_after_insert` фактически не работает**: флаг есть, но логики нет.

## Оптимальная стратегия решения
Сделать ввод и сохранение “самопроверяющимися”, чтобы reload происходил только когда правки точно применились и сохранены.

## План изменений (без выполнения, только дизайн)
### 1) Усилить `fill_scene`: верификация и ретраи
- Реализовать `verify_scene_after_insert` в [heygen_automation.py](file:///Users/ilya/Projects/heygen_automation_V2/heygen_automation.py) (сейчас `pass`).
- Алгоритм:
  - После вставки подождать небольшой debounce (например 200–400мс).
  - Считать текущий текст сцены (через `inner_text` и/или `text_content`).
  - Если текст не совпал (после нормализации) — выполнить 1–2 ретрая:
    - повторно сфокусироваться на сцене,
    - повторить очистку+вставку,
    - в последнем ретрае использовать более “человеческий” метод (например `keyboard.type(..., delay=...)` или paste через clipboard + `Meta+V`) и/или явный blur (клик в безопасную область).
  - Все ретраи обернуть в `perform_step` для логов и артефактов.

### 2) Убрать риск от `Meta+S` и сделать сохранение детерминированным
- В `click_save_and_wait()` поменять порядок:
  - Сначала пытаться **кликнуть UI save-кнопку** (`button:has(iconpark-icon[name="saved"])`) как в старом скрипте.
  - `Meta+S` оставить только как крайнюю меру (или отключить по конфигу), чтобы не провоцировать системный диалог.
- Сделать ожидание сохранения “новым событием”, а не «просто увидеть Saved»:
  - Вариант A: ждать цепочку `Saving… → Saved` (если есть в UI).
  - Вариант B: ждать появление “Saved/Сохранено” после того, как оно было скрыто/отсутствовало (фиксируем baseline видимости до сохранения).
  - Вариант C (лучший, если найдём эндпоинт): `wait_for_response` на save/update запрос HeyGen.

### 3) Защитить `refresh_and_validate` от преждевременного reload
- Перед `page.reload()` добавлять дополнительное ожидание “не грязного состояния” (через выбранную метрику из пункта 2).
- Если сохранить не удалось — делать скриншот/артефакт и **не делать reload**, чтобы не терять изменения.

### 4) Конфиг и обратная совместимость
- Поднять дефолт `verify_scene_after_insert` до `True` (или явно включить для нужных профилей), чтобы проблема не проявлялась молча.
- Добавить настройки количества попыток/задержек, чтобы можно было подстроить под разные шаблоны.

### 5) Обновить документацию и план
- Обновить `docs/PLAN.md`: описать новую логику верификации, сохранения и gate-условия перед reload.

### 6) Быстрая проверка после внедрения
- Прогнать один эпизод/часть в dry-run: убедиться, что после reload тексты остаются.
- Проверить `automation.log`: есть шаги verify/retry, а при ошибках сохраняются скриншоты.

План готов. Одобряете логику для перехода к работе?